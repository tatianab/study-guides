# CS 241 - Advanced Compiler Construction
Professor : Michael Franz  
Quarter   : Winter 2016  

## Scanning and Parsing

## Control Flow Graphs
### Reducibility

## Static Single Assignment
### Phi functions

## Optimizations
### Common Subexpression Elimination
### Copy Propagation

## Register Allocation
**Live ranges**  
Where does a value start / stop living?

**Register pressure**  
Spilling - putting things in memory that you don't have room for.  
SSA - assume unlimited register set, first N are "fast." Compact everything
so that most things can end up at least in the cache.  
So we have: real registers, and "virtual registers" with labels > N.  
Reserve two real registers as proxies for all of the virtual registers (to
store values to be computed on).

### Interference graph
Nodes - SSA values.  
Edges - between two values that co-exist at any point in time.

**Building interference graph**
(Dead code elimination can happen at the same time)  
```
Go from the end of the program to the beginning.
Operands of instructions must be alive.
For each instr i : op j k
	1. live = live - {i}
	2. for all x in live: add edge i <--> x
	3. live = live + {j, k}
```
If/while constructs?

### Linear scan

### Graph coloring
Color a graph with k colors such that no two nodes get the same color.
- This is NP-Hard. We need a heuristic.
- Takes up ~%60 of runtime of compiler.

**Simple algorithm for graph coloring:**  
```
Color(graph): # Given n registers.
	x = arbitrary node with fewer than n neighbors.
	(If no such x exists, take x with lowest cost. This will go into main
	 memory.)
	Remove x and its edges from graph.
	Color(remaining graph)
	Add x and its neighbors back.
	Choose color for x that is different from all neighbors.
	(If no such color exists, allocate storage in memory.)
```
We need a cost function that somehow indicates how many times this value is
used. Higher cost --> more accesses.

Ex. cost function: # of uses, scaled by loop nesting depth.

**SAT Solver for graph coloring**  
SAT solver - constraint solver for propositional satisfiability. 
Given a formula of 0,1, AND, OR and NOT, find a satisfying assignment or
prove that none exists.   

**Example : 4-colorability with SAT solver**  
```
Variables are colors: c0 c1 c2 c3.  
Encode the colors as 2-bit values: 00, 01, 10, or 11.  
If i and j are adjacent in the interference graph, then they have different
color, expressed as:
	NOT ((c_i0 == c_j0) AND (c_i1 == c_j1))
c_i0 == c_j0 is expressed as:
	(c_i0 AND c_j0) OR (NOT c_i0 AND NOT c_j0).
Connect adjacency info with AND, then solve.
```
This results in enormous formulas, and is currently impractical.

## Instruction Scheduling

## Code generation
**Variable Storage**  

| Memory  |                       |
|:--------|:---------------------:|
| 0       | --- Begin Code  ---   |
|         | ... 		  |
|         | --- End Code    ---   | 
|         | --- End Stack   ---   | 
|         | ...                   |  
|         | --- Begin Stack ---   |  
|         | --- End Globals ---   | 
|         | ...                   |   
| MAX     | --- Globals     ---   |  

**DLX Reserved Registers**    
R0  - always 0.  
R28 - FP.  
R29 - SP.  
R30 - Globals.  
R31 - Return address.  

Variables have contiguous addresses (possibly padded to ensure no item spans
more than one line).

### Function handling
**Caller saved vs. callee saved**  
Who keeps track of the state of registers when a function call is made?

**Function calling**  

1. Save return address.
2. Save old frame pointer.
3. Set FP = SP.
4. Reserve space for local variables.

**Activation Record:**  

| -------------- | ------- |
| Parameters     |         |
| Return Address | <- FP   |
| Old FP         |         |
| Locals         | <- SP   |


**Parameter passing**  
Can be via registers or stack.  
In stack, stored above return address.

**Function results**  
Can be via registers or stack. (Probably registers).  

Pre-SSA : register - variable correspondence.   
SSA : register - value correspondence.

## Speculative Processor Features

## Software Pipelining

## Cache-concious Data Structures

## Object-oriented Features
### Single inheritance
### Multiple inheritance

## Security Issues
### Return-oriented programming
### Control flow integrity
